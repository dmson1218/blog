---
title: HTTP 완벽 가이드 3장 HTTP 메시지
tags: ['HTTP']
date: 2024-08-17T03:47:01.000Z
---

## 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들

메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음 선택적으로 데이터가 올 수 있음

HTTP 메시지는 클라이언트, 서버, 프락시 사이를 흐름

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용함

-   메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것
-   모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아운바운드로 이동하는 것

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP 메시지는 강물과 같이 흐르며 요청/응답 관계없이 모두 다운스트림으로 흐름

메시지의 발송자는 수신자의 업스트림

## 3.2 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록

각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함함

메시지는 시작줄, 헤더 블록, 본문 세 부분으로 이루어짐

시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있음

**시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열임**

각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열으로 끝남

이 줄바꿈 문자열은 ‘CRLF’라고 씀

**엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리임**

시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있음

### 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류됨

요청 메시지는 웹 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려줌

-   요청 메시지 형식

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

-   응답 메시지 형식

```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작함

요청 메시지의 시작줄은 무엇을 해야 하는지, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해줌

-   요청줄
    -   요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁함
    -   서버에서 일어나야 하는 동작을 설명해주는 메서드와 대상을 지칭하는 요청 URL이 들어있음
    -   클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함함
    -   모든 필드는 공백으로 구분됨
-   응답줄
    -   수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
    -   응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있음
    -   모든 필드는 공백으로 구분됨
-   메서드
    -   요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해줌
    -   예를 들어, `GET /specials/saw-blade.gif HTTP/1.0`에서 메서드는 GET
    -   HTTP 명세는 공통 요청 메서드의 집합을 정의함
        -   GET: 서버에서 어떤 문서를 가져옴
        -   HEAD: 서버에서 어떤 문서에 대해 헤더만 가져옴
        -   POST: 서버에서 처리해야 할 데이터를 보냄
        -   PUT: 서버에 요청 메시지의 본문을 저장함
        -   TRACE: 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적함
        -   OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인함
        -   DELETE: 서버에서 문서를 제거함
    -   모든 서버가 위 메서드를 모두 구현한 것은 아님
    -   특정 서버는 그들만의 메서드를 추가로 구현했을 수도 있는데, 이를 확장 메서드라고 부름
-   상태 코드
    -   상태 코드는 응답의 시작줄에 위치하며 클라이언트에게 무엇이 일어났는지 말해줌
    -   예를 들어, `HTTP/1.0 200 OK`에서 상태 코드는 200
    -   세 자리 숫자로 된 그들이 코드값을 기준으로 묶임
        -   100-199(100-101 정의됨): 정보
        -   200-299(200-206 정의됨): 성공
            -   200 OK: 성공, 요청한 모든 데이터는 응답 본문에 들어있음
        -   300-399(300-305 정의됨): 리다이렉션
        -   400-499(400-415 정의됨): 클라이언트 에러
            -   401 Unauthorized: 사용자 이름과 비밀번호를 입력해야 함
            -   404 Not Found: 서버가 요청한 URL에 해당하는 리소스를 찾지 못했음
        -   500-599(500-505 정의됨): 서버 에러
    -   인식할 수 없는 상태 코드를 받아도 그것이 포함되는 범주의 일반적인 구성원으로 다뤄야 함
    -   만약 상태 코드 515를 받게 되면, 다른 5XX 메시지들처럼 서버 에러를 의미하는 것으로 다뤄야 함
-   사유 구절
    -   응답 시작줄의 마지막 구성요소로 상태 코드에 대한 글로 된 설명을 제공함
    -   예를 들어, `HTTP/1.0 200 OK`에서 사유 구절은 OK
    -   사유 구절은 상태 코드와 일대일로 대응되는, 상태 코드의 사람이 이해하기 쉬운 버전임
    -   개발자들이 그들의 사용자에게 요청 중 무슨 일이 일어났는지 알려주기 위해 넘겨줄 수 있음
-   버전 번호
    -   HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술됨
    -   HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단임
    -   대화 상대의 능력과 메시지 형식에 대한 단서를 제공해주기 위한 것임
    -   어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킴
    -   응답의 프로토콜 버전이 HTTP/1.1이라는 것은 메시지가 HTTP/1.1 메시지라는 것이 아니라, 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미하는 것임
    -   버전의 각 숫자는 각각 분리된 정수로 다루어짐 (HTTP/2.22 > HTTP/2.3)

### 3.2.3 헤더

시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 옴

HTTP 헤더 필드는 기본적으로 이름/값 쌍의 목록으로, 요청과 응답 메시지에 추가 정보를 더함

HTTP 헤더 명세는 여러 헤더 필드를 정의하지만 애플리케이션은 자유롭게 자신만의 헤더를 만들어낼 수 있음

-   일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
-   요청 헤더: 요청에 대한 부가 정보를 제공
-   응답 헤더: 응답에 대한 부가 정보를 제공
-   Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
-   확장 헤더: 명세에 정의되지 않음 새로운 헤더

각 헤더는 간단한 문법을 가지며 이름, 쉼표, 공백(없어도 됨), 필드 값, CRLF가 순서대로 옴

긴 헤더 줄은 여러 줄로 쪼갤 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 함

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
	Version 1.0
```

### 3.2.4 엔터티 본문

엔터티 본문은 HTTP가 수송하도록 설계된 HTTP 메시지의 화물

HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있음

### 3.2.5 버전 0.9 메시지

HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전으로 오늘날 HTTP 메시지의 시초이지만, 훨씬 단순함

요청은 그저 메서드와 요청 URL를 갖고 있을 뿐이며, 응답은 오직 엔터티로만 되어 있음

버전 정보도 없고(최초의 버전이므로), 상태 코드나 사유 구절도 없으며, 헤더도 포함되어 있지 않음

## 3.3 메서드

모든 서버가 모든 HTTP 메서드를 구현하지는 않음

HTTP 버전 1.1과 호환되고자 한다면, 서버는 자신의 리소스에 대해 GET과 HEAD 메서드만 구현하면 됨

비록 서버가 모든 메서드를 구현하지 않았다 하더라도 메서드는 대부분 제한적으로 사용될 것임

예를 들어, DELETE와 PUT을 지원하는 서버는 아무나 리소스에 접근할 수 있기를 바라지는 않을 것임

이 제한은 일반적으로 서버 설정에 의해 정해지며, 따라서 사이트마다 또 서버마다 다를 수 있음

### 3.3.1 안전한 메서드(Safe Method)

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의함

GET과 HEAD 메서드는 HTTP 요청의 결과로 서버에 어떤 작용도 없기 때문에 안전하다고 할 수 있음

안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없음(사실 웹 개발자에게 달렸음)

대신 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려줄 수 있음

### 3.3.2 GET

주로 서버에게 리소스를 달라고 요청하기 위해 쓰임

HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구함

### 3.3.3 HEAD

정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려주며 엔터티 본문은 결코 반환되지 않음

클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해줌

-   리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있음
-   응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있음
-   헤더를 확인하여 리소스가 변경되었는지 검사할 수 있음

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 함

HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 함

### 3.3.4 PUT

GET 메서드가 서버로부터 문서를 읽어 들이는데 반해 PUT 메서드는 서버에 문서를 씀

서버는 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 교체함

PUT은 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 사용자의 로그인을 미리 요구할 것임

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계되어 실제로 HTML 폼을 지원하기 위해 흔히 사용됨

채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳에 보냄

### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있음

이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있음

TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌

요청으로 어떠한 엔터티 본문도 보낼 수 없고, 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있음

클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답을 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있음

어떻게 TRACE 요청을 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정을 내림

### 3.3.7 OPTIONS

웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봄

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음

여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공함

### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청함

그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못함

HTTP 명세는 서버에 클라이언트에게 알리지 않고 요청을 무시하는 것을 허락하기 때문

### 3.3.9 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않음

확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드

개발자들에게 그들의 서버가 구현한 HTTP 서비스의 리소스에 대한 능력을 확장하는 수단을 제공함

-   LOCK: 사용자가 리소스를 잠글 수 있게 해줌
-   MKCOL: 사용자가 문서를 생성할 수 있게 해줌
-   COPY: 서버에 있는 리소스를 복사함
-   MOVE: 서버에 있는 리소스를 옮김

**“엄격하게 보내고 관대하게 받아들여라”**

## 3.4 상태 코드

상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공함

### 3.4.1 100-199: 정보성 상태 코드

정보성 상태 코드는 HTTP/1.1에서 도입됨

비교적 새로운 것이며, 복잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있음

-   100 Continue
-   101 Switching Protocols

### 3.4.2 200-299: 성공 상태 코드

클라이언트가 요청을 보내면, 그 요청은 대개 성공함

서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응함

-   200 OK
-   201 Created
-   202 Accepted
-   203 Non-Authoritative Information
-   204 No Content
-   205 Reset Content
-   206 Partial Content

### 3.4.3 300-399: 리다이렉션 상태 코드

리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공함

-   300 Multiple Choices
-   301 Moved Permanetly
-   302 Found
-   303 See Other
-   304 Not Modified
-   305 Use Proxy
-   306 (현재 사용되지 않음)
-   307 Temporary Redirect

서버는 가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있음

### 3.4.4 400-499: 클라이언트 에러 상태 코드

가끔 클라이언트는 서버가 다룰 수 없는 무엇인가를 보냄

잘못 구성된 요청 메시지 같은 것이 있을 수도 있고, 가장 흔한 것은 존재하지 않는 URL에 대한 요청임

-   400 Bad Request
-   401 Unauthorized
-   402 Payment Required
-   403 Forbidden
-   404 Not Found
-   405 Method Not Allowed
-   406 Not Acceptable
-   407 Proxy Authentication Required
-   408 Request Timeout
-   409 Conflict
-   410 Gone
-   411 Length Required
-   412 Precondition Failed
-   413 Request Entity Too Large
-   414 Request URI Too Long
-   415 Unsupported Media Type
-   416 Requested Range Not Satifiable
-   417 Expectation Failed

### 3.4.5 500-599: 서버 에러 상태 코드

때때로, 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생할 수 있음

서버의 제한에 걸릴 수도 있고 혹은 게이트웨이 리소스와 같은 서버 보조 구성요소에서 발생할 수 있음

프락시는 클라이언트 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 됨

프락시는 문제를 설명하기 위해 5XX 서버 에러 상태 코드를 생성함

-   500 Internal Server Error
-   501 Not Implemented
-   502 Bad Gateway
-   503 Service Unavailalbe
-   504 Gateway Timeout
-   505 HTTP Version Not Supported

## 3.5 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용됨

### 3.5.1 일반 헤더

메세지가 어떤 종류이든 상관없이 메시지에 대한 아주 기본적이고 유용한 정보를 제공함

-   Connection
-   Date
-   MIME-Version
-   Tralier chunked transfer
-   Transfer-Encoding
-   Upgrade
-   Via

HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 최초로 도입함

최신 버전의 HTTP는 매우 풍부한 캐시 매개변수의 집합을 가지고 있음

기본적인 캐시 헤더는 다음과 같음

-   Cache-Control
-   Pragma

### 3.5.2 요청 헤더

요청 메시지에서만 의미를 갖는 헤더로, 요청이 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나 클라이언트의 선호나 능력에 대한 정보를 줌

서버는 요청 헤더가 준 클라이언트에 대한 정보를 활용해 더 나은 응답을 줄 수 있음

-   Client-IP
-   From
-   Host
-   Referer
-   UA-Color
-   UA-CPU
-   UA-Disp
-   UA-OS
-   UA-Pixels
-   User-Agent

클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있음

즉 무엇을 원하고 무엇을 할 수 있는지, 그리고 무엇보다도 원치 않는 것은 무엇인지 알려줄 수 있음

서버는 그 후 이 추가 정보를 활용해서 무엇을 보낼 것인가에 대해 더 똑똑한 결정을 내릴 수 있음

-   Accept
-   Accept-Charset
-   Accept-Encoding
-   Accept-Language
-   TE

클라이언트는 조건부 요청 헤더를 사용해 서버로 하여금 응답하기 전 조건이 참인지 먼저 확인하게 할 수 있음

-   Expect
-   If-Match
-   If-Modified-Since
-   If-None-Match
-   If-Range
-   If-Unmodified-Since
-   Range

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있음

클라이언트가 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 안전하게 만들고자 함

-   Authorization
-   Cookie
-   Cookie2

프락시가 점점 흔해지면서, 그들의 기능을 돕기 위한 프락시 요청 헤더들이 정의되어 왔음

-   Max-Forwards
-   Proxy-Authorization
-   Proxy-Connection

### 3.5.3 응답 헤더

응답 메시지는 그들만의 응답 헤더를 통해 클라이언트에게 부가 정보를 제공함

누가 응답을 보내고 있는지 혹은 응답자의 능력은 어떻게 되는지, 더 나아가 특별한 설명도 제공할 수 있음

클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와줌

-   Age
-   Public
-   Retry-After
-   Server
-   Title
-   Warning

여러 가지 표현이 가능한 상황이라면, HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인지 협상을 지원함

-   Accept-Ranges
-   Vary

HTTP 인증요구/응답 체계에서 응답 측에 해당하는 응답 보안 헤더는 다음과 같음

-   Proxy-Authenticate
-   Set-Cookie
-   Set-Cookie2
-   WWW-Authenticate

### 3.5.4 엔터티 헤더

요청과 응답 모두 엔터티를 포함할 수 있기 때문에, 엔터티 헤더는 양 타입의 메시지에 모두 나타날 수 있음

엔터티와 그것의 내용물에 대한, 개체의 타입부터 시작해서 주어진 리로스에 대해 요청할 수 있는 유효한 메서드들까지, 광범위한 정보를 제공함

일반적으로 메시지의 수신자에게 자신이 다루고 있는 것인 무엇인지 말해줌

-   Allow
-   Location

콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공함

콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있음

-   Content-Base
-   Content-Encoding
-   Content-Language
-   Content-Length
-   Content-Location
-   Content-MD5
-   Content-Range
-   Content-Type

엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공함

-   ETag
-   Expires
-   Last-Modified
