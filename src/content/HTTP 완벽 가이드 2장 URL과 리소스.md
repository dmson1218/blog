---
title: HTTP 완벽 가이드 2장 URL과 리소스
tags: ['HTTP']
date: 2024-08-05T04:24:01.000Z
---

## 2.1 인터넷의 리소스 탐색하기

URL은 브라우저가 정보를 찾기 위해 필요한 리소스의 위치를 가리킴

-   사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하여 공유할 수 있음
-   HTTP 및 다른 프로토콜을 통해 접근할 수 있음

사용자는 브라우저에 URL을 입력하고 브라우저는 화면 뒤에서 사용자가 원하는 리소스를 얻기 위해서 적절한 프로토콜을 사용하여 메시지를 전송함

URI의 두 가지 주요 부분집합: URL은 리소스가 어디 있는지 설명해서 리소스를 식별하고 URN은 현재 그 리소스가 어디에 존재하든 상관없이 그 이름만으로 리소스를 식별함

HTTP 명세에서는 URI를 더 일반화된 개념의 리소스 식별자로 사용하지만 실제 HTTP 애플리케이션은 URL을 URI의 한 부분으로 취급함

`http://www.dmson1218.com/posts/post1`이라는 URL을 불러오고 싶다고 가정하면

-   URL의 첫 부분인 `http`는 URL의 스킴으로 웹 클라이언트가 리소스에 어떻게 접근하는지 알려줌
-   두 번째 부분인 `www.dmson1218.com`은 서버의 위치로 웹 클라이언트가 리소스가 어디에 호스팅 되어 있는지 알려줌
-   세 번째 부분인 `/posts/post1`은 리소스의 경로로 서버에 존재하는 로컬 리소스들 중에서 요청받은 리소스가 무엇인지 알려줌

URL은 HTTP 프로토콜이 아닌 다른 프로토콜들도 사용할 수 있기에 인터넷의 어떤 리소스든지 가리킬 수 있음

**인터넷상의 모든 리소스를 가리키고 가져오기 위해, 그리고 모든 사람이 같은 방식으로 이름을 써서 리소스를 찾을 수 있도록, 단일 방식의 작명 규칙을 가진 것임**

### 2.1.1 URL이 있기 전 암흑의 시대

웹과 URL이 있기 전, 네트워크상의 산재해 있는 데이터에 접근하기 위해서 애플리케이션마다 달리 가지고 있는 분류 방식을 사용해야 했음

대부분의 사람들은 좋은 애플리케이션을 가지고 있지 않거나, 충분한 요령이나 인내심을 가지고 있지 않았음

URL 덕분에 애플리케이션들에서 하나의 인터페이스를 통해 일관된 방식으로 많은 리소스에 접근할 수 있게 됨

사실 많은 사용자는 브라우저가 사용하는 프로토콜과 접근 방식이 무엇인지 모름

URL은 브라우저가 더 영리하게 리소스에 접근하고 다루게 함으로써 온라인 세상을 단순화시킴

**URL은 정보를 찾는 데 필요한 모든 것을 제공하며, 원하는 리소스가 어디에 위치하고 어떻게 가져오는지 정의함**

## 2.2 URL 문법

URL로 인터넷상의 모든 리소스를 찾을 수 있지만, 그 리소스들은 다른 스킴(예를 들어 HTTP, FTP, SMTP)을 통해 접근할 수 있으며 URL 문법은 스킴에 따라서 달라짐

그렇다고 전혀 다른 문법을 사용하는 것은 아니고, 대부분 일반 URL 문법을 따르며 형태와 문법 면에서 유사함

대부분의 URL 스킴의 문법은 일반적으로 9개의 부분을 나뉨

> <스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>

이 모든 컴포넌트를 가지는 URL은 거의 없고 스킴, 호스트, 경로를 가장 중요한 세 가지 컴포넌트로 여김

-   스킴: 리소스를 가져오려면 어떤 프로토콜을 사용하여 서버에 접근해야 하는지 가리킴
-   사용자 이름: 몇몇 스킴은 리소스에 접근을 하기 위해 사용자 이름을 필요로 함
-   비밀번호: 사용자의 비밀번호를 가리키며, 사용자 이름에 콜론(`:`)으로 이어서 기술함
-   호스트: 리소스를 호스팅하는 서버의 호스트 명이나 IP 주소
-   포트: 리소스를 호스팅하는 서버가 열어놓은 포트번호로 많은 스킴이 기본 포트를 가지고 있음
-   경로: 이전 컴포넌트와 빗금(`/`)으로 구분되어 있으며 서버 내 리소스가 서버 어디에 있는지 가리킴, 경호 컴포넌트의 문법은 서버와 스킴에 따라 다름
-   파라미터: 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용하며 이름/값을 쌍으로 가짐, 다른 파라미터나 경로의 일부와 세미콜론(`;`)으로 구분하여 기술하며 여러 개를 가질 수 있음
-   질의: 스킴에서 애플리케이션에 파라미터를 전달하는 데 쓰이며 공통 포맷은 없음, URL 끝에 `?`로 구분함
-   프래그먼트: 리소스의 조각이나 일부분을 가리키는 이름으로 프래그먼트 필드는 서버에 전달되지 않고 클라이언트에서만 사용함, URL 끝에 `#`로 구분함

### 2.2.1 스킴: 사용할 프로토콜

스킴은 주어진 리소스에 어떻게 접근하는지 알려주는 중요한 정보임

URL을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줌

스킴 컴포넌트는 알파벳으로 시작해야 하고 URL의 나머지 부분들과 첫 번째 `;` 문자로 구분함

대소문자를 가리지 않음

### 2.2.2 호스트와 포트

애플리케이션이 인터넷에 있는 리소스를 찾으려면, 리소스를 호스팅하고 있는 장비와 그 장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야 함

URL의 호스트와 포트 컴포넌트가 그 두 가지 정보를 제공함

호스트 컴포넌트는 리소스를 가지고 있는 인터넷상의 호스트 장비를 가리킴 (호스트 명이나 IP 주소로)

포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킴

내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본 포트로 80을 사용함

### 2.2.3 사용자 이름과 비밀번호

많은 서버가 자신이 가지고 있는 데이터에 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구함

### 2.2.4 경로

URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려줌

계층적 파일 시스템 경로와 유사한 구조를 가짐

경로는 서버가 리소스의 위치를 찾는 데 사용하는 정보로 HTTP URL에서 경로 컴포넌트는 `/` 문자를 기준으로 경로조각으로 나뉨(유닉스 파일 시스템의 파일 경로와 유사하게)

각 경로조각은 자체만의 파라미터 컴포넌트를 가질 수 있음

### 2.2.5 파라미터

많은 스킴이 객체에 대한 호스트 및 경로 정보만으로는 리소스를 찾지 못하며 더 많은 정보가 필요함

URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요함

프로토콜 파라미터가 없으면, 다른 한편에 있는 서버는 그 요청을 잘못 처리하거나 처리하지 않을 것음

URL의 파라미터 컴포넌트는, 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는 데 사용함

이름/값 쌍의 리스트로 URL 나머지 부분들로부터 `;` 문자로 구분하여 URL에 기술함

이를 통해 애플리케이션이 리소스에 접근하는 데 필요한 어떤 추가 정보든 전달할 수 있음

`ftp://prep.ai.mit.edu/pub/gnu;type=d`와 같은 경우 이름은 type이고 값은 d인 파라미터를 전달함

앞서 언급했듯이, 경로 컴포넌트의 각 경로조각은 자체 파라미터를 가질 수 있음

### 2.2.6 질의 문자열

데이터베이스 같은 서비스들은 요청받을 리소스 형식의 범위를 좁히기 위해서 질문이나 질의를 받을 수 있음

예를 들어, `http://www.dmson1218.com/item-check.cgi?item=12731`과 같은 URL은 아이템 번호 12731의 재고가 있는지 확인하기 위해 웹 데이터베이스 게이트웨이에 질의하는 데 사용됨

URL의 질의 컴포넌트는 게이트웨이를 가리키는 URL의 경로 컴포넌트와 함께 전달하고 있음

보통 게이트웨이는, 다른 애플리케이션에 접근하려고 할 때 거치는 통로라고 할 수 있음

특정 문자들을 제외하고 질의 컴포넌트 포맷에 제약사항은 없음

편의상 많은 게이트웨이가 `&`로 나뉜 `이름=값` 쌍 형식의 질의 문자열을 원함

### 2.2.7 프래그먼트

HTML 같은 리소스 형식들은 본래의 수준보다 더 작게 나뉠 수 있음

예를 들어 절(paragraph)이 포함된 용량이 큰 한 개의 텍스트 문서의 경우, 그 리소스에 대한 URL은 텍스트 문서 전체를 가리키겠지만, 이상적으로는 리소스 안에 있는 특정 절을 가리킬 수 있어야 함

리소스의 특정 부분을 가리킬 수 있도록, URL은 리소스 내 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공함

프래그먼트는 URL의 오른쪽에 `#` 문자에 이어서 옴

일반적으로 HTTP 서버는 객체 전체만 다루기 때문에, 클라이언트는 서버에 프래그먼트를 전달하지 않음

브라우저가 서버로부터 전체 리소스를 내려받은 후, 프래그먼트를 사용하여 보고자 하는 리소스 일부를 보여줌

## 2.3 단축 URL

웹 클라이언트는 몇몇 단축 URL을 인식하고 사용함

상대 URL은 리소스 안에 있는 리소스를 간결하게 기술하는 데 사용할 수 있음

많은 브라우저가 URL 일부를 입력하면 나머지 부분을 자동으로 입력해주는 URL 자동 확장을 지원함

### 2.3.1 상대 URL

URL은 상대 URL과 절대 URL 두 가지로 나뉨

절대 URL은 리소스에 접근하는 데 필요한 모든 정보를 가지고 있지만 상대 URL은 모든 정보를 담고 있지는 않음

URL을 짧게 표기하는 방식인 상대 URL로 모든 정보를 얻기 위해서는 기저(base)라고 하는 다른 URL이 필요함

예를 들어, 어떤 HTML 문서 내 `./hammers.html` URL을 가리키는 하이퍼링크는 미완성인 것처럼 보이지만 올바른 문법의 상대 URL로, 해당 HTML 문서의 URL을 기준으로 상대경로로 해석될 수 있음

상대 URL이 갖고 있지 않은 정보는 컴포넌트가 포함된 리소스의 기저 URL에서 알아낼 수 있음

다른 리소스에 대한 URL 역시 상대 URL로 기술할 수 있음

상대 URL은 프래그먼트이거나 URL 일부로, URL을 처리하는 브라우저 같은 애플리케이션은 상대 URL과 절대 URL 간의 상호 변환을 할 수 있어야 함

상대 URL을 사용하면 리소스 집합(HTML 페이지 같은)을 쉽게 변경할 수 있음

문서 집합의 위치를 변경하더라도, 새로운 기저 URL에 의해 해석될 것이기 때문에 잘 동작할 것임

이는 마치 다른 서버에 있는 콘텐츠를 미러링 할 수 있게 허용하는 것과 유사함

-   상대 URL의 절대 URL 변환 첫 단계는 기준이 되는 기저 URL을 찾는 것
    -   리소스에서 명시적으로 제공
        -   어떤 리소스들은 기저 URL을 명확하게 기술(예를 들어 `<BASE>` 태그)하기도 함
    -   리소스를 포함하고 있는 기저 URL
        -   기저 URL이 명시되지 않은 리소스에 포함된 경우, 해당 리소스의 URL을 쓸 수 있음
    -   기저 URL이 없는 경우
        -   보통 절대 URL만으로 이루어져 있다는 뜻이지만 불완전하거나 깨진 URL일 수 있음
-   상대 참조 해석하기
    -   변환 과정의 다음 단계는 상대 URL과 기저 URL을 각각의 컴포넌트 조각으로 나누는 것
    -   URL을 파싱하는 것에 불과하지만, 컴포넌트 단위로 분리하기에 ‘URL 분해하기’라고도 부름
    -   상대 URL을 리소스를 참조하는 데 사용할 수 있는 절대 경로 형태로 변환하는 알고리즘이 존재

### 2.3.2 URL 확장

어떤 브라우저들은 URL을 입력한 다음이나 입력하고 있는 동안에 자동으로 URL을 확장함

자동으로 URL이 확장되기 떄문에 URL 전체를 입력하지 않아도 되어 사용자의 빠른 입력을 도와줌

-   호스트 명 확장
    -   단순한 휴리스틱만을 사용해서 입력한 호스트 명을 전체 호스트 명으로 확장할 수 있음
    -   호스트 명에 `www.`과 `.com`을 자동으로 붙여주는 경우
    -   사이트를 찾지 못한 경우, 확장을 포기하기 전에 몇 가지 URL을 추가 제시하기도 함
    -   브라우저는 이런 간단한 기능을 제공하여 사용자의 시간을 절약하고 혼란을 막아줌
    -   그러나 프락시와 같은 다른 HTTP 애플리케이션에 문제를 발생시킬 수 있음
-   히스토리 확장
    -   과거에 사용자가 방문했던 URL의 기록을 저장해 놓는 것
    -   입력된 URL의 앞 글자들을 포함하는 완결된 형태의 URL을 선택하게 해줌
    -   사용자는 전체 URL을 입력하는 대신 선택만 하면 됨
    -   프락시를 사용할 경우 URL 자동확장 기능을 다르게 동작할 수 있음

## 2.4 안전하지 않은 문자

URL은 잘 호환되도록 설계되었고, 인터넷에 있는 모든 리소스가 여러 프로토콜을 통해서 전달될 수 있도록 각 리소스에 유일한 이름을 지을 수 있게 설계됨

모든 프로토콜이 데이터를 전송하기 위해서 서로 다른 장치를 가지고 있기 때문에, 어떤 인터넷 프로토콜을 통해서든 안전하게 전송될 수 있도록 URL을 설계하는 것은 중요했음

안전한 전송이란, 정보가 유실될 위험 없이 URL을 전송할 수 있다는 것을 의미함

URL 설계자들은 모든 인터넷 프로토콜로 URL이 전송될 수 있기를 바랐고, 이와 함께 가독성도 있기를 바랐음

따라서 출력이 되지 않거나 보이지 않는 문자는 변환될 수 있다 하더라도 URL에서의 사용이 금지됨

사람들이 이진 데이터나 알파벳 외의 문자로 포함하려 할 때가 있어 이스케이프라는 기능을 추가함

### 2.4.1 URL 문자 집합

컴퓨터 시스템의 기본 문자 집합은 보통 영어 중심으로 설정되어 있음

역사적으로 많은 컴퓨터 애플리케이션이 US-ASCII 문자 집합을 사용해왔음

US-ASCII는 유럽 언어나 변형된 문자들, 이진 데이터를 지원하지 않기 때문에 이스케이프 문자열이 쓰이게 됨

이스케이프 문자열은 특정 문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높였음

### 2.4.2 인코딩 체계

안전한 문자 집합의 표현 한계를 넘기 위해, 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안됨

이스케이프 문자는 퍼센티지 기호(`%`)로 시작해, ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어짐

### 2.4.3 문자 제한

몇몇 문자는 URL 내에서 특별한 의미로 예약되어 있고, 어떤 문자는 US-ASCII로 출력이 불가능함

또 어떤 문자는 몇몇 인터넷 게이트웨이와 프로토콜에서 혼동되는 것으로 알려져 있어, 사용이 꺼려짐

예를 들어 `%`, `/`, `.`, `..`, `#`, `?`, `;`, `:`, `$`, `+`, `@`, `&`, `=` 등

### 2.4.4 좀더 알아보기

안전하지 않은 문자를 URL에 사용했어도 아무런 문제가 발생하지 않을 수 있음

어떤 전송 프로토콜에서는 문제가 되지 않기도 하지만, 안전하지 않은 문자를 인코딩하지 않는 것은 실수임

클라이언트 애플리케이션에서 안전하지 않거나 제한된 문자를 변환하는 것이 좋음

스킴이나 컴포넌트마다 제한되는 문자가 다르기 때문에 어떤 문자를 인코딩해야 하는지 결정하는 위치는 브라우저와 같이 사용자로부터 최초로 URL을 입력받는 애플리케이션이 적절함

## 2.5 스킴의 바다

웹에서 쓰이는 일반 스킴들의 포맷

-   `http`
    -   일반 URL 포맷을 지키는 하이퍼텍스트 전송 프로토콜 스킴
    -   사용자 이름이나 비밀번호가 없음
    -   기본 포트값은 80
    -   `http://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>`
-   `https`
    -   http와 거의 같음
    -   HTTP의 커넥션이 양 끝단에서 암호화하기 위해 보안 소켓 계층(SSL)을 사용함
    -   기본 포트값은 443
    -   `https://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>`
-   `mailto`
    -   이메일 주소를 가리킴
    -   이메일은 다른 스킴과는 다르게 동작하기 떄문에, 표준 URL과 다른 포맷을 가짐
    -   `mailto:<RFC-822-addr-spec>`
-   `ftp`
    -   파일 전송 프로토콜 URL은 FTP 서버에 있는 파일을 내려 받거나 올리고, FTP 서버의 디렉터리에 있는 콘텐츠 목록을 가져오는 데 사용할 수 있음
    -   FTP는 웹과 URL이 출현하기 전부터 있었음
    -   웹 애플리케이션은 데이터에 접근하는 용도의 스킴으로 FTP를 사용함
    -   `ftp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>`
-   `rtsp`, `rtspu`
    -   RTSP URL은 실시간 스트리밍 프로토콜을 통해서 읽을 수 있는 미디어 리소스 식별자
    -   오디오 및 비디오 등
    -   `rtspu` 스킴에 있는 `u`는 리소스를 읽기 위해서 UDP 프로토콜이 사용됨을 뜻함
    -   `rtsp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>`
    -   `rtspu://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>`
-   `file`
    -   주어진 호스트 기기에서 바로 접근할 수 있는 파일들을 나타냄
    -   만약 호스트가 생략되어 있으면, URL을 사용하고 있는 기기의 로컬 호스트가 기본값이 됨
    -   `file://<호스트>/<경로>`
-   `news`
    -   RFC 1036에 정의도니 바와 같이 특정 문서나 뉴스 그룹에 접근하는 데 사용됨
    -   리소스의 위치 정보를 충분히 포함하지 않는 특이한 속성이 있음
    -   사용자로부터 호스트 명이나 서버 이름 등의 정보를 알아내는 것은 애플리케이션의 몫
    -   뉴스 리소스는 여러 서버를 통해 접근할 수 있으므로 위치에 독립적이라고 할 수 있음
    -   `@`는 뉴스 그룹을 가리키는 뉴스 URL과 특정 뉴스 문서를 가리키는 뉴스 URL의 구분을 위해 사용됨
    -   `news: <newsgroup>`
    -   `news: <news-article-id>`
-   `telnet`
    -   대화형 서비스에 접근하는 데 사용됨
    -   URL 자체가 객체를 가리키지는 않지만, 리소스라고 할 수 있는 대화형 애플리케이션에 접근할 수 있음
    -   `telnet://<사용자 이름>:<비밀번호>@<호스트>:<포트>/`

## 2.6 미래

URL은 세상에 존재하는 모든 객체에 이름을 지을 수 있고 새로운 포맷을 쉽게 추가할 수 있는 강력한 도구임

URL은 인터넷 프로토콜 간에 공유할 수 있는 일관된 작명 규칙을 제공함

다만, URL은 실제 주소이지 실제 이름이 아니라 특정 시점에 국한되어 있음

만약 리소스가 옮겨지면 기존 URL이 가리키고 있던 객체를 찾을 방법이 없어짐

따라서 객체가 옮겨지더라도 항상 객체를 가리킬 수 있는 이름을 제공하는 URN 작업에 착수하게 됨

지속 통합 자원 지시자(Persistent URL, PURL)을 사용하면 URL로 URN의 기능을 제공할 수 있음

-   리소스의 실제 URL 목록을 관리하는 리소스 위치 중개 서버를 두고, 해당 리소스를 우회적으로 제공
-   클라이언트는 위치 할당자에게 리소스를 가져올 수 있는 영구적인 URL을 요청할 수 있음
-   영구적인 URL은 클라이언트를 리소스의 실제 URL로 연결해줌

### 2.6.1 지금이 아니면, 언제?

URL에서 URN으로 주소 체계를 바꾸는 것은 매우 큰 작업임

표준화는 매우 중요한 작업인 만큼 느리게 진행될 때도 있음

표준을 제정하는 것에서부터 여러 HTTP 애플리케이션을 수정하기 위한 벤더들과의 합의도 필요함

엄청난 작업량이 필요하고 많은 시간이 걸리기 때문에, URL은 당분간 계속 사용될 것임

URL은 나름의 한계를 가지고 있지만, 이를 가장 긴급한 사안이라고 이야기하지는 않음

URL은 현재는 물론 가까운 미래에도 인터넷에 있는 리소스를 명명하는 방법이 될 것임

URL은 그것을 대체할 수 있는 작명 스킴이 나오기 전까지는 계속 사용될 것임

다만 언젠가 URL의 한계를 해결할 수 있는 새로운 표준(아마도 URN)이 나오고 적용될 것임
